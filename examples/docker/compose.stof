/*!
 * Generate a Docker Compose "compose.yaml" file.
 */

/**
 * In real life, I'd define types for this stuff to keep it all super clear and maintainable.
 * Would also add in validation, so that I didn't generate a faulty config.
 *
 * Nice part is that I could re-use this info too to generate more than just my docker compose,
 * and take logic, environment, units, and computed values into consideration.
 */
app: {
    human_name: 'My Application'
    name: 'my-app'
    version: 0.1.0
    description: r#"An application to help dogs find grass via GPS."#;
    services: {
        proxy: {
            image: 'nginx'
            ports: ['80:80']
            volumes: [
                {
                    type: 'bind'
                    source: './proxy/nginx.conf'
                    target: '/etc/nginx/conf.d/default.conf'
                    read_only: true
                }
            ]
            depends_on: ['backend']
        }
        backend: {
            build: {
                context: 'backend'
                target: 'builder'
            }
        }
    }

    fn docker_name() -> str {
        self.name ?? "my-app"
    }
}

fn generate_compose(env: str = 'test') -> obj {
    const app = self.app;
    const services = new {};

    const proxy_name = env + '_proxy';
    services.insert(proxy_name, app.services.proxy);

    const backend_name = env + '_backend';
    services.insert(backend_name, app.services.backend);

    new {
        name: app.docker_name(),
        services,
    }
}

#[main]
/// Run with the command 'stof run examples/docker/compose.stof' from the stof directory.
fn output_compose() {
    const env = 'test';
    const compose = '# Generated with Stof\n' + stringify('yaml', self.generate_compose(env));
    fs.write('examples/docker/compose.yaml', compose);
}
