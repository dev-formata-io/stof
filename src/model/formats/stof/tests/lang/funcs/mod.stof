//
// Copyright 2024 Formata, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//


/*!
 * Function tests.
 * Scope: root.Lang.Funcs
 */

import './init' as self.Init;


#[test]
fn arrow_function() {
    let func = (): int => {
        return 53;
    };
    assert_eq(func(), 53);
}

somescope: {
    // Arrow function as a field!
    fn func: (a: int, b: int) -> int => a + b;

    // Arrow functions don't set the self stack
    stacked: () -> str => {
        self.exists
    }

    // Arena pattern with a field
    arenas: (arena?: obj) => {
        if (arena) arena.done = true;
    }
}

#[test]
fn scoped() {
    let x = self.somescope.func;
    assert_eq(x(40, 2), 42);

    // Can call fields just like normal functions
    assert_eq(self.somescope.func(b = 30, a = 12), 42);
}

#[test]
fn stacked() {
    self.exists = 'stacked';
    let res = self.somescope.stacked();
    assert_eq(res, 'stacked');
}

arena: {}

#[test]
fn test_arenas() {
    self.somescope.arenas(self.arena);
    assert(self.arena.done);
}

#[test]
fn cast_on_return() {
    let func = async (): kg => 45;
    let res: g = func(); // can cast promises with normal types
    assert_eq(typeof res, 'Promise<g>');
    assert_eq(typeof await res, 'g');
}

fn takes_fn(pointer: fn) -> int {
    pointer()
}
#[test]
fn pass_function_pointer() {
    // Can pass async here because promise types work with normal types
    let res = self.takes_fn(async ():int => 42);
    assert_eq(await res, 42);
}
