//
// Copyright 2024 Formata, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//


#[test]
fn async_expr() {
    // any function can be an async function
    const promise = async self.async_expr_test();
    assert_eq(await promise, 578);
}
fn async_expr_test() -> int {
    578
}

#[test]
fn async_block_expr() {
    const res = async {
        return await async {
            let v = 7;
            v * 2
        };
    };
    assert_eq(typeof res, 'Promise<void>'); // basically an unknown promise type
    assert_eq(await res, 14);
}

#[test]
fn async_block() {
    const v = [];

    // creates a new process, just like an async function call
    async {
        v.push_back('hello');
        assert_eq(v, ['hello']);
    }

    // might be empty or have a 'hello' depending on when the process gets executed
    assert(v == [] || v == ['hello']);
}

#[test]
fn async_functions() {
    // can await lists of handles to get a list
    const results = await [self.this_is_async(), self.this_is_also_async()];
    assert_eq(results, ['hello, async', 'async is actually just an attribute']);
}
async fn this_is_async() -> str {
    'hello, async'
}
#[async]
fn this_is_also_async() -> str {
    return 'async is actually just an attribute';
}
