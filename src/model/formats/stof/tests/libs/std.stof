//
// Copyright 2024 Formata, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//


/*!
 * "Std" library tests.
 */


Throw: {
    #[test]
    #[errors]
    fn throw_error() {
        throw('can be any value here');
    }

    #[test]
    fn catch_thrown() {
        let res = 10;
        
        try throw(42);
        catch (val: int) res = val;
        
        assert_eq(res, 42);
    }
}


Print: {
    #[test]
    fn std_print_line() {
        pln('std print line');
    }

    #[test]
    fn std_print_err() {
        err('std print error');
    }

    #[test]
    fn std_debug() {
        dbg('std debug print line');
    }
}


/**
 * Sleep is also in Time, but Stof is async at heart, so here too.
 */
Sleep: {
    #[test]
    fn sleeping_process() {
        // Note: every #[test] is a separate process (async) already, so this won't hold anything up
        sleep(1ms); // default units are ms, but use what you'd like (maybe not days tho)
    }
}


/**
 * Exit a process.
 */
Exit: {
    #[test]
    fn exiting_process() {
        // Note: every #[test] is a separate process, so this will work just fine.
        let another = async {
            loop {
                // This is an infinite loop...
            }
        };
        let yet_another = async {
            sleep(30s);
        };
        exit(another, yet_another); // Exit other processes
        exit(); // Exit this process
    }
}

